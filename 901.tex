
\documentclass{agregfiche}

% V1 par Charlie Jacomme
% Relu avec Thomas Chatain

\title{Leçon 901 - Structures de données. Exemples et applications.}

\begin{document}
\maketitle

\secrapports
\begin{rapport}{2018}
	Le mot algorithme ne figure pas dans l’intitulé de cette leçon, même si l’utilisation des structures de
	données est évidemment fortement liée à des questions algorithmiques. La leçon doit donc être orientée
	plutôt sur la question du choix d’une structure de données. Le jury attend du candidat qu’il présente
	différents types abstraits de structures de données en donnant quelques exemples de leur usage avant de
	s’intéresser au choix de la structure concrète. Le candidat ne peut se limiter à des structures linéaires
	simples comme des tableaux ou des listes, mais doit présenter également quelques structures plus
	complexes, reposant par exemple sur des implantations à l’aide d’arbres. Les notions de complexité des
	opérations usuelles sur la structure de données sont bien sûr essentielles dans cette leçon.
\end{rapport}

\secindispensables

\begin{itemize}
	\item  Types abstraits et implantations concrètes.
    \item Structures linéaires et non linéaires. Exemples de structures complexes.
	\item Complexité des opérations usuelles selon implantation.
\end{itemize}

\secasavoir

\begin{itemize}
	\item  Tableaux, listes, piles, files, file de priorité, arbres, graphes (orientés et non orientés), ensembles, dictionnaires.
    \item Influence de la structure de données sur un algorithme choisi.
    \item Pour un même type de donnée (e.g un graphe), exemples de choix de représentations optimisés selon l'ensemble de données possibles (e.g graphe sparse ou dense)
	\item Notion de coût amorti.
    \item Connaître au moins une structure complexe (tas, union-find, arbres approximativement équilibré,\dots)

\end{itemize}

\secidees

\begin{itemize}
	\item Tas de Fibonacci.
	\item Représentation des graphes.
    	\item Notion de types persistant et mutable.
\end{itemize}

\secpieges

\begin{itemize}
	\item Les algorithmes ne doivent pas être le c\oe ur de la leçon, mais bien les structures de données.
	\item Les dessins sont souvent très appropriés pour représenter des structures de données et leurs évolutions.
   	\item Attention à ne pas s'éparpiller avec trop de structures différentes et à faire un catalogue. Il n'est pas forcément nécéssaire d'écrire tous les interfaces des types abstraits.
	\item Bien avoir en tête les abstractions. Par exemple, un dictionnaire ne porte pas nécéssairement sur des strings.
	\item La complexité, c'est bien, la comparaison des complexités, c'est mieux.
	\item Ne pas être trop lié à un langage de programmation.
	\item Les structures avancés introduites doivent être accompagné d'une application.
\end{itemize}

\secquestionsclassiques

\begin{itemize}
	\item Pourquoi avoir une approche par types abstraits ?
%    les aglorithmes construits au niveau supérieur sont indépendant
%de l'implémentation de ceux en dessous. Modularité.
	\item Quelles structures de données sont en pratique les plus
	utilisées, et intégrées nativement dans les langages de
	programmation ?
%    les listes et les dictionnaires
	\item Connaissez vous l'implémentation des [insérer ici une
	structure] en pratique utilisés ?
%    dictionnaire via table de hachage
	\item Avec les listes chainées/doublement chainées, quelles
	opérations sont plus ou moins complexes ?
%    concaténation, suppresion des doublons
	\item Le choix du type, par exemple persistent et mutable, est souvent lié à des soucis d'efficacité. Y a-t-il d'autres préoccupations lors de la programmation influencées par ce choix ?
    \item Questions techniques/points de détail sur l'une des 
    structures présenté.
    \item Exemples d'utilisation d'une file ? d'une pile ?

\end{itemize}

\secreferences

\begin{itemize}
\item \input{refs/cormen}
\item \input{refs/beauquier}
\item \input{refs/mehlhorn}
\end{itemize}

\secdev

\begin{itemize}
\item[++] \input{dev/tri_tas}
\item[++] \input{dev/hachageparfait}
\item[+] \input{dev/abroptimaux}
\item[+] \input{dev/Arbres2-4}
\end{itemize}


\end{document}